// This file has been autogenerated from a class added in the UI designer.

using System;

using Foundation;
using UIKit;
using CoreGraphics;

namespace ShapeButtonXamarin
{
	public partial class ShapedButton : UIButton
	{
		public const float AlphaVisibleThreshold = 0.1f;

		CGPoint previousTouchPoint;
		bool previousTouchHitTestResponse;
		UIImage buttonImage;
		UIImage buttonBackground;

		public ShapedButton(IntPtr handle) : base (handle)
		{


		}

		public ShapedButton(CGRect frame) : base (frame)
		{
			if (this != null)
			{
				SetUp ();
			}
		}

		public override void AwakeFromNib()
		{
			SetUp ();
		}

		void SetUp()
		{
			UpdateImageCacheForCurrentState ();
			ResetHitTestCache ();
		}


		#region HitTesting

		/// <summary>
		/// Determines whether this instance is alpha visible at point the specified point image.
		/// </summary>
		/// <returns><c>true</c> if this instance is alpha visible at point the specified point image; otherwise, <c>false</c>.</returns>
		/// <param name="point">atPoint</param>
		/// <param name="image">forImage</param>
		bool IsAlphaVisibleAtPoint(CGPoint point, UIImage image)
		{
			// Correct point to take into account that the image does not have to be the same size
			// as the button. See https://github.com/ole/ShapedButton/issues/1
			CGSize iSize = image.Size;
			CGSize bSize = this.Bounds.Size;
			point.X *= (bSize.Width != 0) ? (iSize.Width / bSize.Width) : 1;
			point.Y *= (bSize.Height != 0) ? (iSize.Height / bSize.Height) : 1;

			UIColor pixelColor = UIImage_ColorAtPixel.ColorAtPixel (point, image);
			nfloat alpha = 0.0f;
			nfloat temp;
			pixelColor.GetRGBA (out temp, out temp, out temp, out alpha);
			//			if (pixelColor.RespondsToSelector(new ObjCRuntime.Selector("GetRGBA:")) /*[pixelColor respondsToSelector:@selector(getRed:green:blue:alpha:)]*/)
			//			{
			//				// available from iOS 5.0
			//			}
			//			else
			//			{
			//				// for iOS < 5.0
			//				// In iOS 6.1 this code is not working in release mode, it works only in debug
			//				// CGColorGetAlpha always return 0.
			//				CGColorRef cgPixelColor = [pixelColor CGColor];
			//				alpha = CGColorGetAlpha(cgPixelColor);
			//			}
			return (alpha >= AlphaVisibleThreshold);
		}

		#endregion


		// UIView uses this method in hitTest:withEvent: to determine which subview should receive a touch event.
		// If pointInside:withEvent: returns YES, then the subviewâ€™s hierarchy is traversed; otherwise, its branch
		// of the view hierarchy is ignored.


		public override UIView HitTest(CGPoint point, UIEvent uievent)
		{
			if (!PointInside (point, uievent))
			{
				return null;
			}
			else
			{
				return base.HitTest (point, uievent);
			}
		}

		#region PointInside

		/// <summary>
		/// Points the inside.
		/// </summary>
		/// <returns><c>true</c>, if inside was pointed, <c>false</c> otherwise.</returns>
		/// <param name="point">Point.</param>
		/// <param name="_event">With Event</param>
		bool PointInside(CGPoint point, UIEvent _event)
		{
			// Return NO if even super returns NO (i.e., if point lies outside our bounds)
			bool superResult = base.PointInside (point, _event);
			if (!superResult)
			{
				return superResult;
			}

			// Don't check again if we just queried the same point
			// (because pointInside:withEvent: gets often called multiple times)
			if (point.Equals (previousTouchPoint))
			{
				return previousTouchHitTestResponse;
			}
			else
			{
				previousTouchPoint = point;
			}

			bool response = false;

			if (buttonImage == null && buttonBackground == null)
			{
				response = true;
			}
			else if (buttonImage != null && buttonBackground == null)
			{
				response = IsAlphaVisibleAtPoint (point, buttonImage);
			}
			else if (buttonImage == null && buttonBackground != null)
			{
				response = IsAlphaVisibleAtPoint (point, buttonBackground);
			}
			else
			{
				if (IsAlphaVisibleAtPoint (point, buttonImage))
				{
					response = true;
				}
				else
				{
					response = IsAlphaVisibleAtPoint (point, buttonBackground);
				}
			}

			previousTouchHitTestResponse = response;
			return response;
		}

		#endregion


		// Reset the Hit Test Cache when a new image is assigned to the button
		void SetImage(UIImage image, UIControlState forState)
		{
			base.SetImage (image, forState);
			UpdateImageCacheForCurrentState ();
			ResetHitTestCache ();
		}

		void SetBackgroundImage(UIImage image, UIControlState forState)
		{
			base.SetBackgroundImage (image, forState);
			UpdateImageCacheForCurrentState ();
			ResetHitTestCache ();
		}

		public bool Enabled
		{
			get { return base.Enabled; }
			set
			{
				base.Enabled = value;
				UpdateImageCacheForCurrentState ();
			}
		}

		public bool Highlighted
		{
			get
			{
				return base.Highlighted;
			}


			set
			{
				base.Highlighted = value;
				UpdateImageCacheForCurrentState ();
			}
		}

#pragma warning disable CS0114 // Member hides inherited member; missing override keyword
		public bool Selected
		{
#pragma warning restore CS0114 // Member hides inherited member; missing override keyword
			get { return base.Selected; }
			set
			{
				base.Selected = value;
				UpdateImageCacheForCurrentState ();
			}
		}

		#region HelperMethods

		void UpdateImageCacheForCurrentState()
		{
			buttonBackground = (UIImage)this.CurrentBackgroundImage;
			buttonImage = (UIImage)this.CurrentImage;
		}

		void ResetHitTestCache()
		{
			this.previousTouchPoint = new CGPoint (nfloat.MinValue, nfloat.MinValue);
			this.previousTouchHitTestResponse = false;
		}

		#endregion
	}
}
